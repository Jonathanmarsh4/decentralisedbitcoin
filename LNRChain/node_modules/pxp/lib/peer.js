'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = require('events');
var old = require('old');
var mux = require('multiplex');
var random = require('hat');
var onObject = require('on-object');
var throttle = require('throttle');

var _require = require('stream');

var Transform = _require.Transform;

var Parser = require('stream-parser');
var assign = require('object-assign');
var pxp = require('./pxp.js');

var PROTOCOL_VERSION = 1;
var CANDIDATE_TIMEOUT = 15 * 1000;
var PXP_MAGIC = Buffer('#PXP#');

function isDuplex(stream) {
  return (typeof stream === 'undefined' ? 'undefined' : _typeof(stream)) === 'object' && typeof stream.pipe === 'function' && typeof stream.write === 'function' && typeof stream.read === 'function';
}

// TODO: request timeouts

var Peer = function (_EventEmitter) {
  _inherits(Peer, _EventEmitter);

  function Peer(socket, networks, connectInfo) {
    var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

    _classCallCheck(this, Peer);

    if (!isDuplex(socket)) {
      throw new Error('socket must be a duplex stream');
    }
    if (!networks || Object.keys(networks).length === 0) {
      throw new Error('must specify supported networks');
    }

    var _this = _possibleConstructorReturn(this, (Peer.__proto__ || Object.getPrototypeOf(Peer)).call(this));

    _this.error = _this.error.bind(_this);
    _this.onHello = _this.wrapTryCatch(_this.onHello);
    _this.onGetPeers = _this.wrapTryCatch(_this.onGetPeers);
    // TODO: wrap other handler methods

    _this.connectInfo = connectInfo;
    _this.networks = networks;
    _this.candidates = {};
    _this.closed = false;
    _this.ready = false;
    _this.connected = {};
    _this.remoteNetworks = null;
    _this.remoteConnectInfo = null;
    _this.relayed = opts.relayed;
    _this.relayRateLimit = opts.relayRateLimit || 50 * 1000;

    _this.socket = socket;
    _this.close = _this.close.bind(_this);
    onObject(socket).on({
      error: _this.error,
      close: _this.close,
      disconnect: _this.close,
      end: _this.close
    });

    _this.mux = mux();

    // check magic value at beginning of stream
    // (to ensure peer is using PXP)
    var magicParser = new Transform();
    Parser(magicParser);
    magicParser._bytes(PXP_MAGIC.length, function (magic) {
      magicParser._passthrough(Infinity);
      if (!magic.equals(PXP_MAGIC)) {
        var err = new Error('Invalid magic value, peer not using PXP');
        return _this.error(err);
      }
    });

    // send magic value at beginning of stream
    socket.write(PXP_MAGIC);

    socket.pipe(magicParser).pipe(_this.mux).pipe(socket);

    _this.pxp = pxp(_this.createStream('pxp'));
    _this.pxp.once('hello', _this.onHello.bind(_this));
    _this.sendHello();
    return _this;
  }

  _createClass(Peer, [{
    key: 'wrapTryCatch',
    value: function wrapTryCatch(f) {
      return function () {
        try {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          f.call.apply(f, [this].concat(args));
        } catch (err) {
          this.emit('error', err);
        }
      }.bind(this);
    }
  }, {
    key: 'onceReady',
    value: function onceReady(f) {
      if (this.ready) return f();
      this.once('ready', f);
    }
  }, {
    key: 'selfIsAccepting',
    value: function selfIsAccepting() {
      return !!this.connectInfo;
    }
  }, {
    key: 'isAccepting',
    value: function isAccepting() {
      return !!this.remoteConnectInfo;
    }
  }, {
    key: 'error',
    value: function error(err) {
      this.emit('error', err);
      this.close();
    }
  }, {
    key: 'close',
    value: function close() {
      if (this.closed) return;
      this.closed = true;
      this.emit('disconnect');
      if (typeof this.socket.end === 'function') this.socket.end();
      if (typeof this.socket.destroy === 'function') this.socket.destroy();
      this.mux.unpipe(this.socket);
    }
  }, {
    key: 'createStream',
    value: function createStream(id) {
      var stream = this.mux.createSharedStream(id);
      stream.on('error', this.error);
      return stream;
    }
  }, {
    key: 'getConnectInfo',
    value: function getConnectInfo() {
      return this.remoteConnectInfo;
    }
  }, {
    key: 'sendHello',
    value: function sendHello() {
      this.pxp.send('hello', PROTOCOL_VERSION, this.connectInfo, Object.keys(this.networks));
    }
  }, {
    key: 'onHello',
    value: function onHello(_ref) {
      var _this2 = this;

      var _ref2 = _slicedToArray(_ref, 3);

      var version = _ref2[0];
      var connectInfo = _ref2[1];
      var networks = _ref2[2];

      if (version !== PROTOCOL_VERSION) {
        var err = new Error('Peer has an invalid protocol version.' + ('theirs=' + version + ', ours=' + PROTOCOL_VERSION));
        return this.error(err);
      }

      var commonNetworks = networks.filter(function (n) {
        return Object.keys(_this2.networks).indexOf(n) !== -1;
      });
      if (commonNetworks.length === 0) {
        var _err = new Error('Peer does not have any networks in common.');
        return this.error(_err);
      }

      this.remoteNetworks = networks;
      this.remoteConnectInfo = connectInfo;
      onObject(this.pxp).on({
        getpeers: this.onGetPeers.bind(this),
        relay: this.onRelay.bind(this),
        upgrade: this.onUpgrade.bind(this),
        connect: this.onConnect.bind(this)
      });
      if (this.selfIsAccepting()) {
        this.pxp.on('incoming', this.onIncoming.bind(this));
      }
      this.ready = true;
      this.emit('ready');
    }
  }, {
    key: 'onGetPeers',
    value: function onGetPeers(network, res) {
      var _this3 = this;

      if (!this.networks[network]) {
        var _err2 = new Error('Peer requested an unknown network:' + ('"' + network + '"'));
        res([_err2.message]);
        return this.error(_err2);
      }
      var getPeers = this.networks[network];
      if (typeof getPeers !== 'function') {
        var err = new Error('Invalid getPeers function for network "' + network + '"');
        return this.error(err);
      }
      getPeers.call(this, function (err, peers) {
        if (err) {
          res([true]);
          return _this3.error(err);
        }
        peers = peers.filter(function (p) {
          return p !== _this3;
        });
        var peerInfo = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = peers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var peer = _step.value;

            var id = _this3.addCandidate(peer);
            var connectInfo;
            if (peer instanceof Peer) {
              connectInfo = peer.getConnectInfo();
            } else if (typeof peer === 'function') {
              connectInfo = {
                relay: true,
                pxp: false
              };
              if (peer.getConnectInfo) {
                assign(connectInfo, peer.getConnectInfo());
              }
            } else {
              var _err3 = new Error('Invalid peer object, must be a Peer instance or a function');
              return _this3.emit('error', _err3);
            }
            peerInfo.push({ id: id, network: network, connectInfo: connectInfo });
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        res(null, peerInfo);
      });
    }
  }, {
    key: 'addCandidate',
    value: function addCandidate(peer) {
      var _this4 = this;

      var id = random(32);
      this.candidates[id] = peer;
      var timer = setTimeout(function () {
        return delete _this4.candidates[id];
      }, CANDIDATE_TIMEOUT);
      if (timer.unref) timer.unref();
      // TODO: cleanup timeouts on peer close
      return id;
    }
  }, {
    key: 'onRelay',
    value: function onRelay(_ref3, res) {
      var _this5 = this;

      var _ref4 = _slicedToArray(_ref3, 1);

      var to = _ref4[0];

      // TODO: ensure there isn't already a relay to this destination
      var sourceStream = this.createStream('relay:' + to);
      var dest = this.candidates[to];
      if (!dest) {
        var err = new Error('Peer requested unknown candidate: id=' + to);
        res(err.message);
        return this.error(err);
      }
      var connectRelay = function connectRelay(destStream) {
        sourceStream.pipe(throttle(_this5.relayRateLimit)).pipe(destStream).pipe(throttle(_this5.relayRateLimit)).pipe(sourceStream);
        sourceStream.once('end', function () {
          return destStream.end();
        });
        destStream.once('end', function () {
          return sourceStream.end();
        });
        res(null);
      };
      if (dest instanceof Peer) {
        (function () {
          var id = random(32);
          dest.pxp.send('incoming', [id], function () {
            var destStream = dest.createStream('relay:' + id);
            connectRelay(destStream);
          });
        })();
      } else if (typeof dest === 'function') {
        dest.call(this, function (err, stream) {
          if (err) return _this5.error(err);
          if (!isDuplex(stream)) {
            var _err4 = new Error('Candidate function must pass (err, stream) to callback');
            return _this5.error(_err4);
          }
          connectRelay(stream);
        });
      }
    }
  }, {
    key: 'onIncoming',
    value: function onIncoming(_ref5, res) {
      var _ref6 = _slicedToArray(_ref5, 1);

      var id = _ref6[0];

      var stream = this.createStream('relay:' + id);
      res(null);
      this.emit('incoming', stream);
    }
  }, {
    key: 'onUpgrade',
    value: function onUpgrade(req, res) {
      this.emit('upgrade', req, res);
    }
  }, {
    key: 'onConnect',
    value: function onConnect(network, res) {
      if (this.connected[network]) {
        var err = new Error('Peer tried to connect to network ' + ('"' + network + '" twice'));
        res(err.message);
        return this.error(err);
      }
      var stream = this.createDataStream(network, res);
      this.emit('connect:' + network, stream);
      res(null);
    }
  }, {
    key: 'createDataStream',
    value: function createDataStream(network) {
      var _this6 = this;

      this.connected[network] = true;
      var stream = this.createStream('data:' + network);
      stream.once('end', function () {
        return delete _this6.connected[network];
      });
      return stream;
    }
  }, {
    key: 'connect',
    value: function connect(network, cb) {
      var _this7 = this;

      if (Object.keys(this.networks).indexOf(network) === -1 || this.remoteNetworks.indexOf(network) === -1) {
        var err = new Error('Peer tried to connect for unsupported network "' + network + '"');
        return cb(err);
      }
      if (this.connected[network]) {
        var _err5 = new Error('Already connected for network "' + network + '"');
        return cb(_err5);
      }
      var stream = this.createDataStream(network);
      this.pxp.send('connect', network, function (err) {
        if (err) return cb(new Error(err));
        _this7.emit('connect:' + network, stream);
        cb(null, stream);
      });
    }
  }, {
    key: 'getPeers',
    value: function getPeers(network, cb) {
      this.pxp.send('getpeers', network, function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2);

        var err = _ref8[0];
        var peers = _ref8[1];

        if (err) return cb(new Error(err));
        if (!Array.isArray(peers)) {
          var _err6 = new Error('Peer sent invalid response to "getpeers"');
          return cb(_err6);
        }
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = peers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var peer = _step2.value;

            if (!peer.id || !peer.network) {
              var _err7 = new Error('Peer sent invalid candidate peer');
              return cb(_err7);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        cb(null, peers);
      });
    }
  }, {
    key: 'relay',
    value: function relay(candidate, cb) {
      var _this8 = this;

      this.pxp.send('relay', [candidate.id], function (err) {
        if (err) return cb(new Error(err));
        var relay = _this8.createStream('relay:' + candidate.id);
        cb(null, relay);
      });
    }
  }, {
    key: 'upgrade',
    value: function upgrade(request, cb) {
      if (!this.relayed) {
        return cb(new Error('Can only upgrade relayed connections'));
      }
      this.pxp.send('upgrade', request, function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 2);

        var err = _ref10[0];
        var res = _ref10[1];
        return cb(err, res);
      });
    }
  }]);

  return Peer;
}(EventEmitter);

module.exports = old(Peer);